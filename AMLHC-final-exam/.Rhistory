Q1 <- quantile(x, 0.25, na.rm = TRUE)
Q3 <- quantile(x, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
x[x < lower_bound | x > upper_bound] <- NA
return(x)
}
# Apply the function to replace outliers with NA in each numeric column
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], replace_outliers_with_NA)
# Now, select only the complete cases
diabetes_complete <- diabetes_data[complete.cases(diabetes_data), ]
str(diabetes_complete)
# [Optional: Describe single features (R function describe of package Hmisc)]
description <- describe(diabetes_complete)
print(description)
# Rank features using information gain (package FSelector)
## Convert the class variable to a factor
diabetes_complete$class <- as.factor(diabetes_complete$class)
## Calculate information gain for each feature
info_gain <- information.gain(class ~ ., diabetes_complete)
## Print the information gain for each attribute
print(info_gain)
## Rank the features by information gain
ranked_features <- as.data.frame(info_gain)[order(-info_gain$attr_importance), ]
print(ranked_features)
## Print the information gain values
## Rank the features by information gain
ranked_features <- as.data.frame(info_gain)
ranked_features <- ranked_features[order(-ranked_features$attr_importance), ]
## View the ranked features by information gain
print(ranked_features)
# Create boxplot and distribution plots of one discriminating (i.e., highest IG score) and one non-discriminating feature (i.e., smallest IG score)
knitr::opts_chunk$set(echo = TRUE)
# Replace zeros with NAs for all numeric columns
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], function(x) replace(x, x == 0, NA))
# Define and apply a function for IQR based outlier detection and replace the detected outliers function to replace outliers with NA
replace_outliers_with_NA <- function(x) {
Q1 <- quantile(x, 0.25, na.rm = TRUE)
Q3 <- quantile(x, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
x[x < lower_bound | x > upper_bound] <- NA
return(x)
}
# Apply the function to replace outliers with NA in each numeric column
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], replace_outliers_with_NA)
# Now, select only the complete cases
diabetes_complete <- diabetes_data[complete.cases(diabetes_data), ]
str(diabetes_complete)
# [Optional: Describe single features (R function describe of package Hmisc)]
description <- describe(diabetes_complete)
print(description)
# Rank features using information gain (package FSelector)
## Convert the class variable to a factor
diabetes_complete$class <- as.factor(diabetes_complete$class)
## Calculate information gain for each feature
info_gain <- information.gain(class ~ ., diabetes_complete)
## Convert the results into a readable data frame format
info_gain_df <- as.data.frame(info_gain)
## Sort the features by their information gain values in descending order
ranked_features <- info_gain_df[order(-info_gain_df$attr_importance), ]
## Add row names as a new column in the data frame for readability
ranked_features$feature_name <- rownames(ranked_features)
## Print the ranked features with feature names and information gain
print(ranked_features)
# Create boxplot and distribution plots of one discriminating (i.e., highest IG score) and one non-discriminating feature (i.e., smallest IG score)
## Print the ranked features with feature names and information gain
print(ranked_features)
knitr::opts_chunk$set(echo = TRUE)
# Replace zeros with NAs for all numeric columns
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], function(x) replace(x, x == 0, NA))
# Define and apply a function for IQR based outlier detection and replace the detected outliers function to replace outliers with NA
replace_outliers_with_NA <- function(x) {
Q1 <- quantile(x, 0.25, na.rm = TRUE)
Q3 <- quantile(x, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
x[x < lower_bound | x > upper_bound] <- NA
return(x)
}
# Apply the function to replace outliers with NA in each numeric column
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], replace_outliers_with_NA)
# Now, select only the complete cases
diabetes_complete <- diabetes_data[complete.cases(diabetes_data), ]
str(diabetes_complete)
# [Optional: Describe single features (R function describe of package Hmisc)]
description <- describe(diabetes_complete)
print(description)
# Rank features using information gain (package FSelector)
## Convert the class variable to a factor
diabetes_complete$class <- as.factor(diabetes_complete$class)
## Calculate information gain for each feature
info_gain <- information.gain(class ~ ., diabetes_complete)
## Print the information gain for each attribute
print(info_gain)
## Rank the features by information gain
ranked_features <- as.data.frame(info_gain)[order(-info_gain$attr_importance), ]
print(ranked_features)
## Print the information gain values
## Rank the features by information gain
ranked_features <- as.data.frame(info_gain)
ranked_features <- ranked_features[order(-ranked_features$attr_importance), ]
## View the ranked features by information gain
print(ranked_features)
# Create boxplot and distribution plots of one discriminating (i.e., highest IG score) and one non-discriminating feature (i.e., smallest IG score)
knitr::opts_chunk$set(echo = TRUE)
# Replace zeros with NAs for all numeric columns
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], function(x) replace(x, x == 0, NA))
# Define and apply a function for IQR based outlier detection and replace the detected outliers function to replace outliers with NA
replace_outliers_with_NA <- function(x) {
Q1 <- quantile(x, 0.25, na.rm = TRUE)
Q3 <- quantile(x, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
x[x < lower_bound | x > upper_bound] <- NA
return(x)
}
# Apply the function to replace outliers with NA in each numeric column
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], replace_outliers_with_NA)
# Now, select only the complete cases
diabetes_complete <- diabetes_data[complete.cases(diabetes_data), ]
str(diabetes_complete)
# [Optional: Describe single features (R function describe of package Hmisc)]
description <- describe(diabetes_complete)
print(description)
# Rank features using information gain (package FSelector)
## Convert the class variable to a factor
diabetes_complete$class <- as.factor(diabetes_complete$class)
## Calculate information gain for each feature
info_gain <- information.gain(class ~ ., diabetes_complete)
## Rank the features by information gain
ranked_features <- as.data.frame(info_gain)
ranked_features <- ranked_features[order(-ranked_features$attr_importance), ]
## View the ranked features by information gain
print(ranked_features)
# Create boxplot and distribution plots of one discriminating (i.e., highest IG score) and one non-discriminating feature (i.e., smallest IG score)
## Print the information gain for each attribute
print(info_gain)
knitr::opts_chunk$set(echo = TRUE)
# Replace zeros with NAs for all numeric columns
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], function(x) replace(x, x == 0, NA))
# Define and apply a function for IQR based outlier detection and replace the detected outliers function to replace outliers with NA
replace_outliers_with_NA <- function(x) {
Q1 <- quantile(x, 0.25, na.rm = TRUE)
Q3 <- quantile(x, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
x[x < lower_bound | x > upper_bound] <- NA
return(x)
}
# Apply the function to replace outliers with NA in each numeric column
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], replace_outliers_with_NA)
# Now, select only the complete cases
diabetes_complete <- diabetes_data[complete.cases(diabetes_data), ]
str(diabetes_complete)
# [Optional: Describe single features (R function describe of package Hmisc)]
description <- describe(diabetes_complete)
print(description)
# Rank features using information gain (package FSelector)
## Convert the class variable to a factor
diabetes_complete$class <- as.factor(diabetes_complete$class)
## Calculate information gain for each feature
info_gain <- information.gain(class ~ ., diabetes_complete)
# Convert the results into a readable data frame format
info_gain_df <- as.data.frame(info_gain)
# Sort the features by their information gain values in descending order
ranked_features <- info_gain_df[order(-info_gain_df$attr_importance), ]
# Add row names as a new column in the data frame for readability
ranked_features$feature_name <- rownames(ranked_features)
# Print the ranked features with feature names and information gain
print(ranked_features)
# Create boxplot and distribution plots of one discriminating (i.e., highest IG score) and one non-discriminating feature (i.e., smallest IG score)
knitr::opts_chunk$set(echo = TRUE)
# Replace zeros with NAs for all numeric columns
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], function(x) replace(x, x == 0, NA))
# Define and apply a function for IQR based outlier detection and replace the detected outliers function to replace outliers with NA
replace_outliers_with_NA <- function(x) {
Q1 <- quantile(x, 0.25, na.rm = TRUE)
Q3 <- quantile(x, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
x[x < lower_bound | x > upper_bound] <- NA
return(x)
}
# Apply the function to replace outliers with NA in each numeric column
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], replace_outliers_with_NA)
# Now, select only the complete cases
diabetes_complete <- diabetes_data[complete.cases(diabetes_data), ]
str(diabetes_complete)
# [Optional: Describe single features (R function describe of package Hmisc)]
description <- describe(diabetes_complete)
print(description)
# Rank features using information gain (package FSelector)
## Convert the class variable to a factor
diabetes_complete$class <- as.factor(diabetes_complete$class)
## Calculate information gain for each feature
info_gain <- information.gain(class ~ ., diabetes_complete)
# Convert the results into a readable data frame format
info_gain_df <- as.data.frame(info_gain)
# Ensure that the row names, which are the feature names, are included as a column
info_gain_df$Feature <- rownames(info_gain_df)
# Remove the row names to avoid confusion
rownames(info_gain_df) <- NULL
# Sort the features by their information gain values in descending order
ranked_features <- info_gain_df[order(-info_gain_df$attr_importance), ]
# Print the sorted ranked features
print(ranked_features)
# Create boxplot and distribution plots of one discriminating (i.e., highest IG score) and one non-discriminating feature (i.e., smallest IG score)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE)
# Replace zeros with NAs for all numeric columns
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], function(x) replace(x, x == 0, NA))
# Define and apply a function for IQR based outlier detection and replace the detected outliers function to replace outliers with NA
replace_outliers_with_NA <- function(x) {
Q1 <- quantile(x, 0.25, na.rm = TRUE)
Q3 <- quantile(x, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
x[x < lower_bound | x > upper_bound] <- NA
return(x)
}
# Apply the function to replace outliers with NA in each numeric column
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], replace_outliers_with_NA)
# Now, select only the complete cases
diabetes_complete <- diabetes_data[complete.cases(diabetes_data), ]
str(diabetes_complete)
# [Optional: Describe single features (R function describe of package Hmisc)]
description <- describe(diabetes_complete)
print(description)
# Rank features using information gain (package FSelector)
## Convert the class variable to a factor
diabetes_complete$class <- as.factor(diabetes_complete$class)
## Calculate information gain for each feature
info_gain <- information.gain(class ~ ., diabetes_complete)
# Convert the results into a readable data frame format
info_gain_df <- as.data.frame(info_gain)
# Ensure that the row names, which are the feature names, are included as a column
info_gain_df$Feature <- rownames(info_gain_df)
# Remove the row names to avoid confusion
rownames(info_gain_df) <- NULL
# Sort the features by their information gain values in descending order
ranked_features <- info_gain_df[order(-info_gain_df$attr_importance), ]
# Print the sorted ranked features
print(ranked_features)
# Create boxplot and distribution plots of one discriminating (i.e., highest IG score) and one non-discriminating feature (i.e., smallest IG score)
# Boxplot for the most discriminating feature
ggplot(diabetes_complete, aes(x = class, y = plas)) +
geom_boxplot() +
labs(title = "Boxplot of Plasma Glucose by Class",
x = "Class",
y = "Plasma Glucose Levels")
# Distribution plot for the most discriminating feature
ggplot(diabetes_complete, aes(x = plas, fill = class)) +
geom_histogram(binwidth = 10, position = "identity", alpha = 0.5) +
labs(title = "Distribution of Plasma Glucose by Class",
x = "Plasma Glucose Levels",
y = "Count") +
theme_minimal()
# Boxplot for the least discriminating feature
ggplot(diabetes_complete, aes(x = class, y = pedi)) +
geom_boxplot() +
labs(title = "Boxplot of Pedigree Function by Class",
x = "Class",
y = "Pedigree Function")
# Distribution plot for the least discriminating feature
ggplot(diabetes_complete, aes(x = pedi, fill = class)) +
geom_histogram(binwidth = 0.1, position = "identity", alpha = 0.5) +
labs(title = "Distribution of Pedigree Function by Class",
x = "Pedigree Function",
y = "Count") +
theme_minimal()
library(ggplot2)
# Extracting the scores for PC1 and PC2
scores_df <- data.frame(PC1 = pca_result$scores[,1], PC2 = pca_result$scores[,2])
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
# Load dataset food.csv
food_data <- read.csv("food.csv", header = TRUE, sep = ",")
# Analyze the dimensions of the dataset
dim_food_data <- dim(food_data) # Gets the dimensions of the data frame
cat("Dimensions of dataset: ", dim_food_data, "\n") # Prints out the dimensions
# Calculate the number of missing values in the dataset
num_missing_values <- sum(is.na(food_data)) # Counts the total number of NA values
cat("Number of missing values: ", num_missing_values, "\n") # Prints out the number of missing values
# Feature scaling using z-transformation (standardization)
scaled_food_data <- scale(food_data[,-1])
# To check the scaling, let's look at the summary of the first few features
# This gives the mean and standard deviation which should be 0 and 1, respectively, after scaling
summary_scaled_food_data <- summary(scaled_food_data)
print(summary_scaled_food_data) # Prints a summary statistics of the scaled data
# Perform PCA using the princomp function
pca_result <- princomp(scaled_food_data)
# Print a summary of the PCA results to get eigenvalues and the proportion of variance
summary(pca_result)
# View the loadings for the PCA components
loadings(pca_result)
# Eigenvalues can give us the variance explained by each principal component
pca_result$sdev^2
# To see the proportion of variance explained by the principal components
prop_var_explained <- pca_result$sdev^2 / sum(pca_result$sdev^2)
prop_var_explained
# Extracting the scores for PC1 and PC2
scores_df <- data.frame(PC1 = pca_result$scores[,1], PC2 = pca_result$scores[,2])
# Creating a score plot with PC1 and PC2
qplot(data = scores_df, x = PC1, y = PC2, xlab = "PC1", ylab = "PC2", main = "PCA Score Plot")
# Extracting the scores for PC1 and PC2
scores_df <- data.frame(PC1 = pca_result$scores[,1], PC2 = pca_result$scores[,2])
# Creating a score plot with PC1 and PC2
ggplot(data = scores_df, aes(x = PC1, y = PC2)) +
geom_point() +  # Adds a scatter plot layer
theme_minimal() +  # Optional: Applies a minimalistic theme
labs(title = "PCA Score Plot", x = "PC1 (Principal Component 1)", y = "PC2 (Principal Component 2)")  # Adds labels
```{r load dataset, echo = FALSE}
# Create the confusion matrix
install.packages(caret)
# Define the predicted and actual classes
predicted <- c("Benign", "Malignant", "Malignant")
actual <- c("Benign", "Benign", "Malignant")
# Create the confusion matrix
install.packages(caret)
library(caret)
# Create the confusion matrix
install.package(caret)
# Create the confusion matrix
install.packages(caret)
# Create the confusion matrix
install.packages("caret")
knitr::opts_chunk$set(echo = FALSE)
#Set Working Directory with setwd("path_to_folder")
#load libraries
library(ggplot2)
library(dplyr)
library(FSelector)
library(rpart)
library(rpart.plot)
#Load Data
diabetes_data <- read.csv("diabetic_data.csv")
# Getting an Overview
# Structure of the dataset
str(diabetes_data)
dim(diabetes_data)
distinct_values <- lapply(diabetes_data, unique)
print(distinct_values)
# Create a bar plot for the readmitted variable
bar_plot <- ggplot(diabetes_data, aes(x = readmitted)) +
geom_bar(fill = "blue", color = "black") +
labs(title = "Histogram of Readmitted Patients",
x = "Readmission Status",
y = "Count") +
theme_minimal()
# Print the plot object
print(bar_plot)
# how many encounters are there?
num_unique_encounters <- length(unique(diabetes_data$encounter_id))
print(paste("Number of unique encounters:", num_unique_encounters))
# Number of unique patients
num_unique_patients <- length(unique(diabetes_data$patient_nbr))
print(paste("Number of unique patients:", num_unique_patients))
# Count the number of occurrences of each patient_nbr
patient_counts <- table(diabetes_data$patient_nbr)
# Identify patient_nbr that are unique (appear only once)
unique_patient_nbr <- names(patient_counts[patient_counts == 1])
# Create a data frame excluding rows with unique patient_nbr
df_non_unique_patients <- diabetes_data[!(diabetes_data$patient_nbr %in% unique_patient_nbr), ]
readmission_status_non_unique <- table(df_non_unique_patients$readmitted)
cat("Readmission status for non-unique patients:\n")
print(readmission_status_non_unique)
# Create a data frame only containing rows with unique patient_nbr
df_unique_patients <- diabetes_data[diabetes_data$patient_nbr %in% unique_patient_nbr, ]
readmission_status_unique <- table(df_unique_patients$readmitted)
cat("Readmission status for unique patients:\n")
print(readmission_status_unique)
# Print the number of rows in each data frame to verify
cat("Number of rows in df_non_unique_patients:", nrow(df_non_unique_patients), "\n")
cat("Number of rows in df_unique_patients:", nrow(df_unique_patients), "\n")
# Calculate the percentage of missing values for each attribute
missing_values <- sapply(diabetes_data, function(x) sum(is.na(x)) / length(x) * 100)
# Create a data frame with the results
missing_values_df <- data.frame(
attribute = names(missing_values),
missing_percentage = missing_values
)
# Print the resulting data frame
print(missing_values_df)
# Create a data frame with the results
missing_values_df <- data.frame(
missing_percentage = missing_values
)
# Print the resulting data frame
print(missing_values_df)
# Create a bar plot for the readmitted variable
bar_plot <- ggplot(diabetes_data, aes(x = readmitted)) +
geom_bar(fill = "blue", color = "black") +
labs(title = "Histogram of Readmitted Patients",
x = "Readmission Status",
y = "Count") +
theme_minimal()
# Replacing "?" with NA
diabetes_data[diabetes_data == "?"] <- NA
# Calculate the percentage of missing values for each attribute
missing_values <- sapply(diabetes_data, function(x) sum(is.na(x)) / length(x) * 100)
# Create a data frame with the results
missing_values_df <- data.frame(
missing_percentage = missing_values
)
# Print the resulting data frame
print(missing_values_df)
# Filter the data frame to include only variables with missing percentage > 0
missing_values_filtered <- missing_values_df[missing_values_df$missing_percentage > 0, ]
# Add a row for "All other Variables"
all_others_row <- data.frame(
attribute = "All other Variables",
missing_percentage = 0
)
# Create a data frame with the results
missing_values_df <- data.frame(
attribute = names(missing_values),
missing_percentage = missing_values
)
# Filter the data frame to include only variables with missing percentage > 0
missing_values_filtered <- missing_values_df[missing_values_df$missing_percentage > 0, ]
# Add a row for "All other Variables"
all_others_row <- data.frame(
attribute = "All other Variables",
missing_percentage = 0
)
# Combine the filtered data frame with the "All other Variables" row
final_missing_values_df <- rbind(missing_values_filtered, all_others_row)
# Print the resulting data frame
print(final_missing_values_df)
# Combine the filtered data frame with the "All other Variables" row
final_missing_values_df <- rbind(missing_values_filtered, all_others_row)
final_missing_values_df$missing_percentage <- round(final_missing_values_df$missing_percentage, 2)
# Print the resulting data frame
print(final_missing_values_df)
rownames(final_missing_values_df) <- NULL
# Print the resulting data frame
print(final_missing_values_df)
colnames(diabetes_data)
# Erstellen des Modells
logistic_model <- glm(
readmitted ~ A1Cresult + race + age + medical_specialty + diag_1 + time_in_hospital + ,
# Erstellen des Modells
logistic_model <- glm(
readmitted ~ A1Cresult + race + age + medical_specialty + diag_1 + time_in_hospital,
data = diabetes_data,
family = binomial
)
str(diabetes_data$readmitted)
install.packages("nnet")
library(nnet)
knitr::opts_chunk$set(echo = FALSE)
#Set Working Directory with setwd("path_to_folder")
#load libraries
library(ggplot2)
library(dplyr)
library(FSelector)
library(rpart)
library(rpart.plot)
library(nnet)
#Zielvariable in Faktor umwandeln
diabetes_data$readmitted <- factor(diabetes_data$readmitted, levels = c("NO", ">30", "<30"))
# Erstellen des Modells
multinom_model <- multinom(readmitted ~ HbA1Cresult + race + age + medical_specialty + diag_1 + time_in_hospital, data = diabetes_data)
# Erstellen des Modells
multinom_model <- multinom(readmitted ~ A1Cresult + race + age + medical_specialty + diag_1 + time_in_hospital, data = diabetes_data)
# Erstellen des Modells
multinom_model <- multinom(readmitted ~ A1Cresult + race + age, data = diabetes_data)
# Zusammenfassung des Modells anzeigen
summary(logistic_model)
# Zusammenfassung des Modells anzeigen
summary(multinom_model)
# Erstellen des Modells
multinom_model <- multinom(readmitted ~ A1Cresult + diag_1, data = diabetes_data)
setwd("~/Library/Mobile Documents/com~apple~CloudDocs/Studium/UMIT/Modul 12/AMLHC_Tasks_JS1/AMLHC-final-exam")
##Logistische Regression HbA1c
```{r log_regression, echo = TRUE}
knitr::opts_chunk$set(echo = FALSE)
#Set Working Directory with setwd("path_to_folder")
#
#load libraries
library(ggplot2)
library(dplyr)
library(FSelector)
library(rpart)
library(rpart.plot)
library(nnet)
# Create a bar plot for the readmitted variable
bar_plot <- ggplot(diabetes_data, aes(x = readmitted)) +
geom_bar(fill = "blue", color = "black") +
labs(title = "Histogram of Readmitted Patients",
x = "Readmission Status",
y = "Count") +
theme_minimal()
# Print the plot object
print(bar_plot)
# Print the number of rows in each data frame to verify
cat("Number of rows in df_non_unique_patients:", nrow(df_non_unique_patients), "\n")
cat("Number of rows in df_unique_patients:", nrow(df_unique_patients), "\n")
# Delete columns weight, payer:code, medical_specialty and diag_3
diabetes_data <- diabetes_data[, !(colnames(diabetes_data) %in% c("weight", "payer_code", "medical_specialty", "diag_3"))]
# Print the resulting data frame
print(final_missing_values_df)
# Delete all rows where the variable "race" is NA
diabetes_data <- diabetes_data[!is.na(diabetes_data$race), ]
