knitr::opts_chunk$set(echo = TRUE)
class(FHS_uebung.CHD_inc)
class(FHS_uebung$CHD_inc)
knitr::opts_chunk$set(echo = TRUE)
library(haven)
FHS_uebung <- read.csv("FHS_uebung.csv")
str(FHS_uebung)
FHS_uebung$SEX <- as.factor(FHS_uebung$SEX)
FHS_uebung$SBP_bin <- as.factor(FHS_uebung$SBP_bin)
FHS_uebung$CHD_inc <- as.factor(FHS_uebung$CHD_inc)
table(FHS_uebung$AGE)
table(FHS_uebung$SEX)
table(FHS_uebung$SBP)
table(FHS_uebung$SBP_bin)
table(FHS_uebung$CHD_inc)
barplot(table(FHS_uebung$AGE))
barplot(table(FHS_uebung$SEX))
barplot(table(FHS_uebung$SBP))
barplot(table(FHS_uebung$SBP_bin))
barplot(table(FHS_uebung$CHD_inc))
mean(FHS_uebung$AGE, na.rm = TRUE)
mean(FHS_uebung$SBP, na.rm = TRUE)
sd(FHS_uebung$AGE, na.rm = TRUE)
sd(FHS_uebung$SBP, na.rm = TRUE)
names(sort(table(FHS_uebung$SEX), decreasing = TRUE)[1])
names(sort(table(FHS_uebung$SBP_bin), decreasing = TRUE)[1])
names(sort(table(FHS_uebung$CHD_inc), decreasing = TRUE)[1])
# Für AGE
hist(FHS_uebung$AGE, main="Histogram of AGE", xlab="AGE")
# Für SBP
hist(FHS_uebung$SBP, main="Histogram of SBP", xlab="SBP")
# Laden des e1071 Pakets
library(e1071)
# Berechnung der Schiefe für AGE
skewness_age <- skewness(FHS_uebung$AGE, na.rm = TRUE)
print(paste("Skewness of AGE: ", skewness_age))
# Berechnung der Kurtosis für AGE
kurtosis_age <- kurtosis(FHS_uebung$AGE, na.rm = TRUE)
print(paste("Kurtosis of AGE: ", kurtosis_age))
# Berechnung der Schiefe für SBP
skewness_sbp <- skewness(FHS_uebung$SBP, na.rm = TRUE)
print(paste("Skewness of SBP: ", skewness_sbp))
# Berechnung der Kurtosis für SBP
kurtosis_sbp <- kurtosis(FHS_uebung$SBP, na.rm = TRUE)
print(paste("Kurtosis of SBP: ", kurtosis_sbp))
library(haven)
FHS_uebung <- read.csv("FHS_uebung.csv")
str(FHS_uebung)
# Chi-Quadrat-Test
chisq.test(table(FHS_uebung$SBP_bin, FHS_uebung$CHD_inc))
# Chi-Quadrat-Test
chisq.test(table(FHS_uebung$SBP_bin, FHS_uebung$CHD_inc), correct = FALSE)
is.integer(FHS_uebung$SBP)
is.integer(FHS_uebung$AGE)
plot(FHS_uebung$AGE, FHS_uebung$SBP, main="Zusammenhang zwischen Alter und Blutdruck",
xlab="Alter", ylab="Blutdruck", pch=19, col="blue")
linear_modell <- lm(SBP ~ AGE, data=FHS_uebung)
summary(linear_modell)
multi_modell <- lm(SBP ~ AGE + SEX + CHOL, data = FHS_uebung)
summary(multi_modell)
FHS_uebung_clean <- na.omit(FHS_uebung)
full_model <- lm(SBP ~ SEX + AGE + CHOL + FRW + CIG, data = FHS_uebung_clean)
reduced_model <- step(full_model, direction = "backward")
summary(reduced_model)
class(FHS_uebung$CHD_inc)
unique(FHS_uebung$CHD_inc)
logistic_model <- glm(CHD_inc ~ SBP, data = FHS_uebung, family = binomial)
summary(logistic_model)
class(FHS_uebung$SBP)
class(FHS_uebung$SEX)
unique(FHS_uebung$SEX)
logistic_model <- glm(CHD_inc ~ SBP, data = FHS_uebung, family = binomial)
summary(logistic_model)
log_model_2 <- glm(CHD_inc ~ SBP + SEX, family = binomial, data = FHS_uebung)
summary(log_model_2)
# Erstellen des vollständigen Modells mit allen Prädiktoren
log_model_3 <- glm(CHD_inc ~ AGE + CHOL + SBP + CIG + FRW, data = FHS_uebung, family = binomial)
# Durchführung der Rückwärtselimination
log_model_3_reduced <- step(log_model_3, direction = "backward")
# Erstellen des vollständigen Modells mit allen Prädiktoren
log_model_3 <- glm(CHD_inc ~ AGE + CHOL + SBP + CIG + FRW, data = FHS_uebung_clean, family = binomial)
# Durchführung der Rückwärtselimination
log_model_3_reduced <- step(log_model_3, direction = "backward")
# Anzeigen des finalen Modells
summary(log_model_3_reduced)
```{r log regression 3}
# Erstellen des vollständigen Modells mit allen Prädiktoren
log_model_3 <- glm(CHD_inc ~ AGE + CHOL + SBP + CIG + FRW + SEX, data = FHS_uebung_clean, family = binomial)
# Durchführung der Rückwärtselimination
log_model_3_reduced <- step(log_model_3, direction = "backward")
# Anzeigen des finalen Modells
summary(log_model_3_reduced)
exp(0.915770−1.96×0.147290)
exp(0.915770 - 1.96×0.147290)
exp(0.915770 - 1.96 * 0.147290)
exp(0.915770 + 1.96 * 0.147290)
exp(0.915770 - 1.96 * 0.147290)
exp(0.018539 + 1.96 * 0.002416)
exp(0.018539 - 1.96 * 0.002416)
setwd("~/Desktop/Task_2_1")
food_data <- read.csv("food.csv", header = TRUE, sep = ",")
food_data <- read.csv("food.csv", header = TRUE, sep = ",")
# Analyze the dimensions of the dataset
dim_food_data <- dim(food_data) # Gets the dimensions of the data frame
cat("Dimensions of dataset: ", dim_food_data, "\n") # Prints out the dimensions
View(food_data)
num_missing_values <- sum(is.na(food_data)) # Counts the total number of NA values
cat("Number of missing values: ", num_missing_values, "\n") # Prints out the number of missing values
# Feature scaling using z-transformation (standardization)
scaled_food_data <- scale(food_data, center = TRUE, scale = TRUE)
# Feature scaling using z-transformation (standardization)
scaled_food_data <- scale(food_data[,-1])
View(scaled_food_data)
# To check the scaling, let's look at the summary of the first few features
# This gives the mean and standard deviation which should be 0 and 1, respectively, after scaling
summary_scaled_food_data <- summary(scaled_food_data)
print(summary_scaled_food_data) # Prints a summary statistics of the scaled data
print(summary_scaled_food_data) # Prints a summary statistics of the scaled data
# Perform PCA using the princomp function
pca_result <- princomp(scaled_food_data)
# Print a summary of the PCA results to get eigenvalues and the proportion of variance
summary(pca_result)
# View the loadings for the PCA components
loadings(pca_result)
# Eigenvalues can give you the variance explained by each principal component
pca_result$sdev^2
# To see the proportion of variance explained by the principal components
prop_var_explained <- pca_result$sdev^2 / sum(pca_result$sdev^2)
prop_var_explained
setwd("/Users/johannesschwietering/Library/Mobile Documents/com~apple~CloudDocs/Studium/UMIT/Modul 12/AMLHC_Tasks_JS1")
setwd("/Users/johannesschwietering/Library/Mobile Documents/com~apple~CloudDocs/Studium/UMIT/Modul 12/AMLHC_Tasks_JS1/Task_2_1")
setwd("/Users/johannesschwietering/Library/Mobile Documents/com~apple~CloudDocs/Studium/UMIT/Modul 12/AMLHC_Tasks_JS1")
root.dir = "/Users/johannesschwietering/Library/Mobile Documents/com~apple~CloudDocs/Studium/UMIT/Modul 12/AMLHC_Tasks_JS1"
knitr::opts_chunk$set(echo = TRUE)
root.dir = "/Users/johannesschwietering/Library/Mobile Documents/com~apple~CloudDocs/Studium/UMIT/Modul 12/AMLHC_Tasks_JS1"
# Load dataset food.csv
food_data <- read.csv("food.csv", header = TRUE, sep = ",")
# Perform PCA using the princomp function
pca_result <- princomp(scaled_food_data)
# Print a summary of the PCA results to get eigenvalues and the proportion of variance
summary(pca_result)
# View the loadings for the PCA components
loadings(pca_result)
# Eigenvalues can give us the variance explained by each principal component
pca_result$sdev^2
# To see the proportion of variance explained by the principal components
prop_var_explained <- pca_result$sdev^2 / sum(pca_result$sdev^2)
prop_var_explained
setwd("~/Library/Mobile Documents/com~apple~CloudDocs/Studium/UMIT/Modul 12/AMLHC_Tasks_JS1/Task_2_2")
knitr::opts_chunk$set(echo = TRUE)
diabetes_data <- read.csv("diabetes.csv", header = TRUE, sep = ",")
View(diabetes_data)
# Define a function for detecting outliers based on the IQR
detect_outliers <- function(x) {
Q1 <- quantile(x, 0.25)
Q3 <- quantile(x, 0.75)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
outliers <- x < lower_bound | x > upper_bound
return(outliers)
}
# Apply the outlier detection function to each column of the dataset
outliers_list <- lapply(diabetes[, sapply(diabetes, is.numeric)], detect_outliers)
# Define a function for detecting outliers based on the IQR
detect_outliers <- function(x) {
Q1 <- quantile(x, 0.25)
Q3 <- quantile(x, 0.75)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
outliers <- x < lower_bound | x > upper_bound
return(outliers)
}
# Apply the outlier detection function to each column of the dataset
outliers_list <- lapply(diabetes_data[, sapply(diabetes, is.numeric)], detect_outliers)
# Define a function for detecting outliers based on the IQR
detect_outliers <- function(x) {
Q1 <- quantile(x, 0.25)
Q3 <- quantile(x, 0.75)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
outliers <- x < lower_bound | x > upper_bound
return(outliers)
}
# Apply the outlier detection function to each column of the dataset
outliers_list <- lapply(diabetes_data[, sapply(diabetes_data, is.numeric)], detect_outliers)
# If you want to know the number of outliers per column, you can do:
sapply(outliers_list, sum)
# Apply the outlier detection function to each column of the dataset
outliers_list <- lapply(diabetes_data[, sapply(diabetes_data, is.numeric)], detect_outliers)
# Apply the outlier detection function to each column of the dataset
outliers_list <- lapply(diabetes_data[, sapply(diabetes_data, is.numeric)], detect_outliers)
print(outliers_list)
knitr::opts_chunk$set(echo = TRUE)
# Define a function for detecting outliers based on the IQR
detect_outliers <- function(x) {
Q1 <- quantile(x, 0.25)
Q3 <- quantile(x, 0.75)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
outliers <- x < lower_bound | x > upper_bound
return(outliers)
}
# Apply the outlier detection function to each column of the dataset
outliers_list <- lapply(diabetes_data[, sapply(diabetes_data, is.numeric)], detect_outliers)
# If you want to know the number of outliers per column, you can do:
sapply(outliers_list, sum)
# Replace zeros with NAs for all numeric columns
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], function(x) replace(x, x == 0, NA))
# Update the detect_outliers function to replace outliers with NA
replace_outliers_with_NA <- function(x) {
Q1 <- quantile(x, 0.25, na.rm = TRUE)
Q3 <- quantile(x, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
x[x < lower_bound | x > upper_bound] <- NA
return(x)
}
# Apply the function to replace outliers with NA in each numeric column
diabetes_data[sapply(diabetes_data, is.numeric)] <- lapply(diabetes_data[sapply(diabetes_data, is.numeric)], replace_outliers_with_NA)
# Now, select only the complete cases
diabetes_complete <- diabetes_data[complete.cases(diabetes_data), ]
# [Optional: Describe single features (R function describe of package Hmisc)]
install.packages("Hmisc")
install.packages("Hmisc")
install.packages("Hmisc")
install.packages("Hmisc")
install.packages("Hmisc")
install.packages("Hmisc")
install.packages("Hmisc")
install.packages("Hmisc")
install.packages("Hmisc")
install.packages("Hmisc")
library(Hmisc)
